#!/bin/bash

# AI Global: Unified AI Tools Configuration Manager
# https://github.com/nanxiaobei/ai-global

set -e

CONFIG_DIR="$HOME/.ai-global"
BACKUP_DIR="$CONFIG_DIR/backups"
GLOBAL_MD="$CONFIG_DIR/AGENTS.md"
SKILLS_DIR="$CONFIG_DIR/skills"
AGENTS_DIR="$CONFIG_DIR/agents"
RULES_DIR="$CONFIG_DIR/rules"
COMMANDS_DIR="$CONFIG_DIR/commands"

# Version
VERSION="1.13.0"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
GRAY='\033[0;90m'
BRIGHT_RED='\033[1;31m'
BRIGHT_GREEN='\033[1;32m'
BRIGHT_YELLOW='\033[1;33m'
BRIGHT_BLUE='\033[1;34m'
BRIGHT_MAGENTA='\033[1;35m'
BRIGHT_CYAN='\033[1;36m'
NC='\033[0m'

# Tool color palette (using bright xterm-256 colors for 26 tools)
# All colors are bright and visually distinct for better visibility
TOOL_COLORS=(
    "\033[38;5;226m" # Bright Yellow
    "\033[38;5;46m"  # Bright Green
    "\033[38;5;51m"  # Bright Cyan
    "\033[38;5;180m" # Light Blue (replaced Bright Blue)
    "\033[38;5;201m" # Bright Magenta
    "\033[38;5;208m" # Bright Orange
    "\033[38;5;9m"   # Red
    "\033[38;5;11m"  # Yellow
    "\033[38;5;10m"  # Green
    "\033[38;5;14m"  # Cyan
    "\033[38;5;12m"  # Blue
    "\033[38;5;13m"  # Magenta
    "\033[38;5;214m" # Orange
    "\033[38;5;220m" # Gold
    "\033[38;5;82m"  # Aquamarine
    "\033[38;5;117m" # Light Blue
    "\033[38;5;165m" # Purple
    "\033[38;5;118m" # Lime Green
    "\033[38;5;225m" # Pink
    "\033[38;5;39m"  # Sky Blue
    "\033[38;5;129m" # Bright Purple
    "\033[38;5;203m" # Rose
    "\033[38;5;77m"  # Spring Green
    "\033[38;5;215m" # Salmon
    "\033[38;5;159m" # Light Cyan
    "\033[38;5;147m" # Pale Blue
)

beautify_path() {
    local path="$1"
    if [[ "$path" == "$HOME"* ]]; then
        local beautified="~${path#$HOME}"
        echo "${beautified//\/\///}"
    else
        echo "$path"
    fi
}

get_tool_color() {
    local name="$1"
    local sum=0
    local len=${#name}
    for (( i=0; i<len; i++ )); do
        sum=$((sum + $(printf '%d' "'${name:i:1}")))
    done
    echo -e "${TOOL_COLORS[$((sum % ${#TOOL_COLORS[@]}))]}"
}

# Extract name from frontmatter (name: "...")
extract_meta_name() {
    local file="$1"
    local default_name="$2"
    if [[ ! -f "$file" ]]; then
        echo "$default_name"
        return
    fi
    # Match name: "value" or name: value
    local extracted=$(grep -m 1 "^name:" "$file" | sed -E 's/^name:[[:space:]]*["'\'']?([^"'\'']+)["'\'']?/\1/' | xargs 2>/dev/null || true)
    if [[ -n "$extracted" ]]; then
        echo "$extracted"
    else
        echo "$default_name"
    fi
}

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_ok() { echo -e "${GREEN}[OK]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Known AI tool patterns
# Format: dir|key|name|agents_md|skills_dir|agents_dir|rules_dir|commands_dir
declare -a KNOWN_PATTERNS=(
    ".claude|claude|Claude Code|CLAUDE.md|skills|agents|.|commands"
    ".codex|codex|OpenAI Codex|AGENTS.md|skills|agents|rules|."
    ".cursor|cursor|Cursor|rules/AGENTS.md|skills|agents|rules|commands"
    ".factory|droid|Factory Droid|AGENTS.md|skills|droids|rules|commands"
    ".amp|amp|Amp|AGENTS.md|skills|.|rules|commands"
    ".gemini|antigravity|Antigravity|GEMINI.md|antigravity/skills|.|.|."
    ".gemini|gemini|Gemini CLI|GEMINI.md|skills|.|.|."
    ".kiro|kiro|Kiro CLI|steering/AGENTS.md|skills|agents|steering|."
    ".config/opencode|opencode|OpenCode|AGENTS.md|skill|agents|.|command"
    ".qoder|qoder|Qoder|AGENTS.md|skills|agents|rules|commands"
    ".qodo|qodo|Qodo|AGENTS.md|.|agents|.|."
    ".copilot|copilot|GitHub Copilot|AGENTS.md|skills|agents|.|."
    ".continue|continue|Continue|AGENTS.md|.|.|rules|."
    ".codeium/windsurf|windsurf|Windsurf|AGENTS.md|skills|.|rules|."
    ".roo|roo|Roo Code|AGENTS.md|skills|.|rules|commands"
    ".cline|cline|Cline|AGENTS.md|skills|.|rules|."
    ".blackbox|blackbox|Blackbox AI|.|skills|.|.|."
    ".goose|goose|Goose AI|AGENTS.md|skills|.|.|."
    ".augment|augment|Augment|AGENTS.md|.|agents|rules|commands"
    ".clawdbot|clawdbot|Clawdbot Code|AGENTS.md|skills|subagents|.|."
    ".commandcode|commandcode|Command Code|AGENTS.md|skills|.|.|commands"
    ".kilocode|kilocode|Kilo Code|AGENTS.md|skills|.|rules|commands"
    ".neovate|neovate|Neovate|AGENTS.md|skills|agents|.|commands"
    ".openhands|openhands|OpenHands|AGENTS.md|skills|.|.|."
    ".trae|trae|TRAE|AGENTS.md|skills|.|rules|."
    ".zencoder|zencoder|Zencoder|AGENTS.md|skills|.|rules|."
)

# Backup a file or directory
backup_item() {
    local source="$1"
    local tool_dir="$2"
    local type="$3"

    [[ ! -e "$source" ]] && return 0
    [[ -L "$source" ]] && return 0

    mkdir -p "$BACKUP_DIR"

    local backup_name=$(echo "$tool_dir" | tr '/' '_')
    local timestamp=$(date +%s)
    local backup_path="$BACKUP_DIR/${backup_name}.${type}.${timestamp}"

    if [[ -d "$source" ]]; then
        cp -r "$source" "$backup_path" 2>/dev/null || return 0
    else
        cp "$source" "$backup_path" 2>/dev/null || return 0
    fi

    log_ok "Backed up: $source"
}

# Merge items from a tool to shared directory (dedup by filename)
merge_items() {
    local source_dir="$1"
    local target_dir="$2"
    local type="$3"
    local tool_name="$4"

    [[ ! -d "$source_dir" ]] && return
    [[ -L "$source_dir" ]] && return

    local merged_count=0

    for item in "$source_dir"/*; do
        [[ ! -e "$item" ]] && continue
        local name=$(basename "$item")
        local target="$target_dir/$name"

        [[ -e "$target" ]] && continue

        if [[ -d "$item" ]]; then
            cp -r "$item" "$target"
        else
            cp "$item" "$target"
        fi
        ((merged_count++))
    done

    if [[ $merged_count -gt 0 ]]; then
        local tool_color=$(get_tool_color "$tool_name")
        log_ok "Merged $merged_count $type from ${tool_color}${tool_name}${NC}"
    fi
}

# Count items in directory (dirs and files)
count_items() {
    local dir="$1"
    if [[ -d "$dir" ]]; then
        ls -1 "$dir" 2>/dev/null | wc -l | tr -d ' '
    else
        echo "0"
    fi
}

# Create symlink
create_symlink() {
    local source="$1"
    local target="$2"

    [[ ! -e "$source" ]] && return

    local target_dir=$(dirname "$target")
    mkdir -p "$target_dir"

    # If target exists and is a real file/dir, it should have been backed up by backup_item already.
    # We remove it to make room for the symlink, avoiding in-place backups.
    if [[ -e "$target" ]] && [[ ! -L "$target" ]]; then
        rm -rf "$target"
    fi

    [[ -L "$target" ]] && rm "$target"
    ln -s "$source" "$target"
}

# Show symlink status
show_status() {
    log_info "Symlink status:"
    echo ""

    local total_links=0

    # Instructions
    local instr_output=""
    for pattern in "${KNOWN_PATTERNS[@]}"; do
        local p_dir p_name p_instr p_skills p_agents p_rules p_cmds
        IFS='|' read -r p_dir p_key p_name p_instr p_skills p_agents p_rules p_cmds <<< "$pattern"

        if [[ "$p_instr" != "." ]] && [[ "$p_instr" == *.md ]]; then
            local target="$HOME/$p_dir/$p_instr"
            if [[ -L "$target" ]]; then
                local link_target=$(readlink "$target" 2>/dev/null || true)
                if [[ "$link_target" == *".ai-global"* ]]; then
                    local tool_color=$(get_tool_color "$p_name")
                    instr_output+="  ${tool_color}$(beautify_path "$target")${NC}\n"
                    ((total_links++))
                fi
            fi
        fi
    done

    if [[ -n "$instr_output" ]]; then
        echo -e "${BLUE}[AGENTS.md]${NC}"
        echo -e -n "$instr_output"
    fi

    for type_name in skills agents rules commands; do
        local type_output=""
        for pattern in "${KNOWN_PATTERNS[@]}"; do
            local p_dir p_name p_instr p_skills p_agents p_rules p_cmds
            IFS='|' read -r p_dir p_key p_name p_instr p_skills p_agents p_rules p_cmds <<< "$pattern"

            local type_dir=""
            case "$type_name" in
                skills)   type_dir="$p_skills" ;;
                agents)   type_dir="$p_agents" ;;
                rules)    type_dir="$p_rules" ;;
                commands) type_dir="$p_cmds" ;;
            esac

            if [[ "$type_dir" != "." ]]; then
                local target="$HOME/$p_dir/$type_dir"
                if [[ -L "$target" ]]; then
                    local link_target=$(readlink "$target" 2>/dev/null || true)
                    if [[ "$link_target" == *".ai-global"* ]]; then
                        local tool_color=$(get_tool_color "$p_name")
                        type_output+="  ${tool_color}$(beautify_path "$target")${NC}\n"
                        ((total_links++))
                    fi
                fi
            fi
        done

        if [[ -n "$type_output" ]]; then
            echo -e "\n${BLUE}[$type_name]${NC}"
            echo -e -n "$type_output"
        fi
    done

    if [[ $total_links -eq 0 ]]; then
        echo "  No active symlinks found."
    fi

    echo ""
    log_info "Shared items: skills=$(count_items "$SKILLS_DIR"), agents=$(count_items "$AGENTS_DIR"), rules=$(count_items "$RULES_DIR"), commands=$(count_items "$COMMANDS_DIR")"
}

# List supported tools
list_supported() {
    log_info "Supported AI tools:"
    echo ""
    printf "  ${BLUE}%-16s %-12s %-15s %-7s %-7s %-7s %-6s %-11s %s${NC}\n" "Tool" "Key" "Directory" "AGENTS.md" "Skills" "Agents" "Rules" "Commands" "Status"
    echo "  ----------------------------------------------------------------------------------------------------"

    for pattern in "${KNOWN_PATTERNS[@]}"; do
        local p_dir p_name p_instr p_skills p_agents p_rules p_cmds
        IFS='|' read -r p_dir p_key p_name p_instr p_skills p_agents p_rules p_cmds <<< "$pattern"
        local full_path="$HOME/$p_dir"

        local g_str="." s_str="." a_str="." r_str="." c_str="."

        # Check what the tool supports based on KNOWN_PATTERNS
        if [[ "$p_instr" != "." ]]; then
            g_str="○"
        else
            g_str="${GRAY}.${NC}"
        fi
        if [[ "$p_skills" != "." ]]; then
            s_str="○"
        else
            s_str="${GRAY}.${NC}"
        fi
        if [[ "$p_agents" != "." ]]; then
            a_str="○"
        else
            a_str="${GRAY}.${NC}"
        fi
        if [[ "$p_rules" != "." ]]; then
            r_str="○"
        else
            r_str="${GRAY}.${NC}"
        fi
        if [[ "$p_cmds" != "." ]]; then
            c_str="○"
        else
            c_str="${GRAY}.${NC}"
        fi

        # If tool is installed, check if the configs actually exist
        if [[ -d "$full_path" ]]; then
            [[ "$p_instr" != "." && "$p_instr" == *.md && -f "$full_path/$p_instr" ]] && g_str="○"
            [[ "$p_skills" != "." && -d "$full_path/$p_skills" ]] && s_str="○"
            [[ "$p_agents" != "." && -d "$full_path/$p_agents" ]] && a_str="○"
            [[ "$p_rules" != "." && -d "$full_path/$p_rules" ]] && r_str="○"
            [[ "$p_cmds" != "." && -d "$full_path/$p_cmds" ]] && c_str="○"
        fi

        local status=""
        local tool_color=""

        if [[ -d "$full_path" ]]; then
            status="${GREEN}Installed${NC}"
            tool_color=$(get_tool_color "$p_name")
        else
            status="${GRAY}Not found${NC}"
            tool_color="${GRAY}"

            # For not found tools, make all symbols gray too
            if [[ "$g_str" == "○" ]]; then
                g_str="${GRAY}○${NC}"
            fi
            if [[ "$s_str" == "○" ]]; then
                s_str="${GRAY}○${NC}"
            fi
            if [[ "$a_str" == "○" ]]; then
                a_str="${GRAY}○${NC}"
            fi
            if [[ "$r_str" == "○" ]]; then
                r_str="${GRAY}○${NC}"
            fi
            if [[ "$c_str" == "○" ]]; then
                c_str="${GRAY}○${NC}"
            fi
        fi

        echo -e "  ${tool_color}${p_name:0:16}$(printf '%*s' $((16 - ${#p_name})) | tr ' ' ' ') ${p_key:0:12}$(printf '%*s' $((12 - ${#p_key})) | tr ' ' ' ') ${p_dir:0:19}$(printf '%*s' $((19 - ${#p_dir})) | tr ' ' ' ')${NC} ${g_str}       ${s_str}       ${a_str}       ${r_str}       ${c_str}        ${status}"
    done
    echo ""
}

# List available backups
list_backups() {
    log_info "Available backups:"
    echo ""

    # Use ls -A to catch hidden files/dirs (starting with .)
    local backups_list=$(ls -A "$BACKUP_DIR" 2>/dev/null || true)

    if [[ -z "$backups_list" ]]; then
        echo "  No backups found"
        echo ""
        return
    fi

    printf "  ${BLUE}%-18s %-10s %s${NC}\n" "Tool" "Type" "Backup File"
    echo "  -----------------------------------------------------------------------------------"

    while read -r filename; do
        [[ -z "$filename" ]] && continue
        local tool_name=""
        local type=""

        # Improved regex to handle various path characters
        # Format: backup_name.type.timestamp where backup_name has '/' replaced with '_'
        if [[ "$filename" =~ ^(.+)\.([^.]+)\.([0-9]+)$ ]]; then
            # Convert underscores back to slashes for display
            tool_name="${BASH_REMATCH[1]//_//}"
            type="${BASH_REMATCH[2]}"
        else
            tool_name="$filename"
            type="unknown"
        fi

        local tool_color=$(get_tool_color "${tool_name//_/ }")
        # Print the backup filename as a path prefixed with ~/ using beautify_path
        local backup_path=$(beautify_path "$BACKUP_DIR/$filename")
        printf "  %s%-18s %-10s %s%b\n" "$tool_color" "$tool_name" "$type" "$backup_path" "$NC"
    done <<< "$backups_list"
    echo ""
}

# Collect and merge AGENTS.md from all tools
collect_agents_md() {
    local merged_content=""
    local found_count=0

    for pattern in "${KNOWN_PATTERNS[@]}"; do
        IFS='|' read -r dir_name key tool_name agents_md skills agents rules commands <<< "$pattern"

        if [[ "$agents_md" != "." ]] && [[ "$agents_md" == *.md ]]; then
            local actual_path="$HOME/$dir_name/$agents_md"
            [[ -L "$actual_path" ]] && continue

            if [[ -f "$actual_path" ]]; then
                local content=$(cat "$actual_path" 2>/dev/null)
                if [[ -n "$content" ]]; then
                    if [[ $found_count -gt 0 ]]; then
                        merged_content+="\n\n---\n\n"
                    fi
                    merged_content+="# From $tool_name\n\n$content"
                    ((found_count++))
                fi
            fi
        fi
    done

    # Skip if AGENTS.md already exists
    if [[ -f "$GLOBAL_MD" ]]; then
        log_ok "Preserved existing $GLOBAL_MD (skipped merge)"
        return
    fi

    # Only create and merge if AGENTS.md doesn't exist
    if [[ $found_count -gt 0 ]]; then
        echo -e "$merged_content" > "$GLOBAL_MD"
        log_ok "Merged instructions from $found_count tool(s) to $GLOBAL_MD"
    else
        cat > "$GLOBAL_MD" << 'EOF'
# AI Assistant Instructions

<!-- Add your instructions here. They will sync to all AI tools. -->
EOF
        log_ok "Created: $GLOBAL_MD"
    fi
}

# Update: scan, merge and link tools
update_tools() {
    log_info "Scanning for AI tools..."
    echo ""

    mkdir -p "$SKILLS_DIR" "$AGENTS_DIR" "$RULES_DIR" "$COMMANDS_DIR" "$BACKUP_DIR"

    # Check and rename global.md to AGENTS.md if it exists
    if [[ -f "$CONFIG_DIR/global.md" ]]; then
        log_info "Found legacy global.md file, renaming to AGENTS.md..."
        mv "$CONFIG_DIR/global.md" "$CONFIG_DIR/AGENTS.md"
        log_ok "Renamed global.md to AGENTS.md"
    fi

    collect_agents_md

    local tool_count=0

    for pattern in "${KNOWN_PATTERNS[@]}"; do
        IFS='|' read -r dir_name key tool_name agents_md skills agents rules commands <<< "$pattern"
        local full_path="$HOME/$dir_name"

        if [[ -d "$full_path" ]]; then
            local color=$(get_tool_color "$tool_name")
            echo -e "${GREEN}[OK]${NC} ${color}Found: $tool_name${NC}"
            ((tool_count++))

            if [[ "$agents_md" != "." ]] && [[ "$agents_md" == *.md ]]; then
                local actual_path="$HOME/$dir_name/$agents_md"
                backup_item "$actual_path" "$dir_name" "instructions"
            fi

            for type_name in skills agents rules commands; do
                local type_dir=""
                case "$type_name" in
                    skills) type_dir="$skills" ;;
                    agents) type_dir="$agents" ;;
                    rules) type_dir="$rules" ;;
                    commands) type_dir="$commands" ;;
                esac
                if [[ "$type_dir" != "." ]]; then
                    local path="$HOME/$dir_name/$type_dir"
                    backup_item "$path" "$dir_name" "$type_name"
                    local target_dir=""
                    case "$type_name" in
                        skills) target_dir="$SKILLS_DIR" ;;
                        agents) target_dir="$AGENTS_DIR" ;;
                        rules) target_dir="$RULES_DIR" ;;
                        commands) target_dir="$COMMANDS_DIR" ;;
                    esac
                    merge_items "$path" "$target_dir" "$type_name" "$tool_name"
                fi
            done
        fi
    done

    if [[ $tool_count -eq 0 ]]; then
        log_info "No AI tools found."
        return
    fi

    echo ""
    log_info "Creating symlinks..."

    for pattern in "${KNOWN_PATTERNS[@]}"; do
        IFS='|' read -r dir_name key tool_name agents_md skills agents rules commands <<< "$pattern"
        local full_path="$HOME/$dir_name"

        if [[ -d "$full_path" ]]; then
            local tool_color=$(get_tool_color "$tool_name")
            if [[ "$agents_md" != "." ]] && [[ "$agents_md" == *.md ]]; then
                local target="$HOME/$dir_name/$agents_md"
                create_symlink "$GLOBAL_MD" "$target"
                printf "${tool_color}%-40s -> %s${NC}\n" "$(beautify_path "$target")" "$(beautify_path "$GLOBAL_MD")"
            fi

            for type_name in skills agents rules commands; do
                local type_dir=""
                local source_dir=""
                case "$type_name" in
                    skills) type_dir="$skills"; source_dir="$SKILLS_DIR" ;;
                    agents) type_dir="$agents"; source_dir="$AGENTS_DIR" ;;
                    rules) type_dir="$rules"; source_dir="$RULES_DIR" ;;
                    commands) type_dir="$commands"; source_dir="$COMMANDS_DIR" ;;
                esac
                if [[ "$type_dir" != "." ]]; then
                    local target="$HOME/$dir_name/$type_dir"
                    create_symlink "$source_dir" "$target"
                    printf "${tool_color}%-40s -> %s${NC}\n" "$(beautify_path "$target")" "$(beautify_path "$source_dir")/"
                fi
            done
        fi
    done

    echo ""
    log_info "Done! Shared: skills=$(count_items "$SKILLS_DIR"), agents=$(count_items "$AGENTS_DIR"), rules=$(count_items "$RULES_DIR"), commands=$(count_items "$COMMANDS_DIR")"
}

# Unlink a single tool
unlink_single_tool() {
    local tool_name="$1"
    local dir_name="$2"
    local agents_md="$3"
    local skills="$4"
    local agents="$5"
    local rules="$6"
    local commands="$7"
    local silent="${8:-false}"

    local backup_name=$(echo "$dir_name" | tr '/' '_')
    local worked=false

    # Check for instructions link
    if [[ "$agents_md" != "." ]]; then
        local target="$HOME/$dir_name/$agents_md"
        if [[ -L "$target" ]]; then
            local link_target=$(readlink "$target" 2>/dev/null || true)
            if [[ "$link_target" == *".ai-global"* ]]; then
                rm "$target"
                local backup_file=$(ls -t "$BACKUP_DIR"/${backup_name}.instructions.* 2>/dev/null | head -1)
                [[ -f "$backup_file" ]] && cp "$backup_file" "$target"
                worked=true
            fi
        fi
    fi

    # Check for components links
    for type_name in skills agents rules commands; do
        local type_dir=""
        case "$type_name" in
            skills) type_dir="$skills" ;;
            agents) type_dir="$agents" ;;
            rules) type_dir="$rules" ;;
            commands) type_dir="$commands" ;;
        esac
        if [[ "$type_dir" != "." ]]; then
            local target="$HOME/$dir_name/$type_dir"
            if [[ -L "$target" ]]; then
                local link_target=$(readlink "$target" 2>/dev/null || true)
                if [[ "$link_target" == *".ai-global"* ]]; then
                    rm "$target"
                    local backup_file=$(ls -td "$BACKUP_DIR"/${backup_name}.${type_name}.* 2>/dev/null | head -1)
                    if [[ -d "$backup_file" ]]; then
                        cp -r "$backup_file" "$target"
                    fi
                    worked=true
                fi
            fi
        fi
    done

    # Check for backups persistence
    local has_backups=false
    if [[ -n "$(ls "$BACKUP_DIR"/${backup_name}.* 2>/dev/null)" ]]; then
        has_backups=true
        rm -rf "$BACKUP_DIR"/${backup_name}.* 2>/dev/null || true
    fi

    if [[ "$worked" == true ]] || [[ "$has_backups" == true ]]; then
        if [[ "$silent" != "true" ]]; then
            local color=$(get_tool_color "$tool_name")
            echo -e "${GREEN}[OK]${NC} ${color}Unlinked: $tool_name${NC}"
        fi
        return 0
    fi

    return 1
}

# Unlink all tools
unlink_all_tools() {
    log_info "Unlinking tools..."
    echo ""

    local unlinked_count=0
    # Scan all known patterns to find and remove any symlinks
    for pattern in "${KNOWN_PATTERNS[@]}"; do
        IFS='|' read -r dir_name key tool_name agents_md skills agents rules commands <<< "$pattern"
        if unlink_single_tool "$tool_name" "$dir_name" "$agents_md" "$skills" "$agents" "$rules" "$commands"; then
            ((unlinked_count++))
        fi
    done

    # Final sweep for any remaining symlinks pointing to .ai-global
    find "$HOME" -maxdepth 3 -type l 2>/dev/null | while read -r link; do
        local target=$(readlink "$link" 2>/dev/null || true)
        if [[ "$target" == *".ai-global"* ]]; then
            rm "$link"
            log_ok "Removed unknown symlink: $(beautify_path "$link")"
            ((unlinked_count++))
        fi
    done

    # Clear all backups as requested
    rm -rf "$BACKUP_DIR"/* 2>/dev/null || true

    echo ""
    if [[ $unlinked_count -gt 0 ]]; then
        log_info "Unlinked $unlinked_count item(s) and cleared backups. Shared data preserved."
    else
        log_info "No active symlinks found. Backups cleared."
    fi
}

# Unlink a specific tool
unlink_tool() {
    local tool_query="$1"

    if [[ -z "$tool_query" ]]; then
        log_error "Usage: ai-global unlink <tool> or ai-global unlink all"
        echo ""
        list_backups
        return 1
    fi

    if [[ "$tool_query" == "all" ]]; then
        unlink_all_tools
        return
    fi

    local found=false

    for pattern in "${KNOWN_PATTERNS[@]}"; do
        IFS='|' read -r dir_name key tool_name agents_md skills agents rules commands <<< "$pattern"
        local tool_lower=$(echo "$tool_name" | tr '[:upper:]' '[:lower:]')
        local query_lower=$(echo "$tool_query" | tr '[:upper:]' '[:lower:]')

        if [[ "$tool_lower" == *"$query_lower"* ]] || [[ "$dir_name" == *"$query_lower"* ]] || [[ "$key" == "$query_lower" ]]; then
            if ! unlink_single_tool "$tool_name" "$dir_name" "$agents_md" "$skills" "$agents" "$rules" "$commands"; then
                log_info "$tool_name is not currently linked."
            fi
            found=true
            break
        fi
    done

    if [[ "$found" == false ]]; then
        log_error "Tool not found: $tool_query"
        echo ""
        echo "Use 'ai-global list' to see supported tools"
        return 1
    fi
}

# Check if input is a GitHub reference
is_github_ref() {
    local input="$1"
    # Match: user/repo, https://github.com/user/repo, github.com/user/repo
    if [[ "$input" =~ ^https?://github\.com/ ]] || \
       [[ "$input" =~ ^github\.com/ ]] || \
       [[ "$input" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+(/.*)?$ ]]; then
        return 0
    fi
    return 1
}

# Parse GitHub reference to get owner, repo, and optional path
parse_github_ref() {
    local input="$1"

    # Remove https://github.com/ or github.com/ prefix
    input="${input#https://github.com/}"
    input="${input#http://github.com/}"
    input="${input#github.com/}"

    # Remove /blob/main/ or /blob/master/ or /tree/main/ etc for file/dir paths
    input=$(echo "$input" | sed -E 's|/blob/[^/]+/|/|; s|/tree/[^/]+/|/|')

    echo "$input"
}

# Download from GitHub
download_from_github() {
    local type="$1"
    local ref="$2"
    local target_dir="$3"

    local parsed=$(parse_github_ref "$ref")
    local owner=$(echo "$parsed" | cut -d'/' -f1)
    local repo=$(echo "$parsed" | cut -d'/' -f2)
    local path=$(echo "$parsed" | cut -d'/' -f3-)

    if [[ -z "$owner" ]] || [[ -z "$repo" ]]; then
        log_error "Invalid GitHub reference: $ref"
        return 1
    fi

    # If path points to a specific file
    if [[ -n "$path" ]] && [[ "$path" == *.md ]]; then
        local filename=$(basename "$path")
        local raw_url="https://raw.githubusercontent.com/$owner/$repo/main/$path"

        log_info "Downloading: $raw_url"

        if curl -fsSL "$raw_url" -o "$target_dir/$filename" 2>/dev/null; then
            log_ok "Added $type: $target_dir/$filename"
        else
            # Try master branch
            raw_url="https://raw.githubusercontent.com/$owner/$repo/master/$path"
            if curl -fsSL "$raw_url" -o "$target_dir/$filename" 2>/dev/null; then
                log_ok "Added $type: $target_dir/$filename"
            else
                log_error "Failed to download: $ref"
                return 1
            fi
        fi
    else
        # Clone entire repo or subdirectory
        local tmp_dir=$(mktemp -d)
        local clone_url="https://github.com/$owner/$repo.git"

        log_info "Cloning: $clone_url"

        if git clone --depth 1 --single-branch "$clone_url" "$tmp_dir/$repo"; then
            local source_dir="$tmp_dir/$repo"
            [[ -n "$path" ]] && source_dir="$tmp_dir/$repo/$path"

            if [[ -d "$source_dir" ]]; then
                local count=0
                local meta_file=""
                case "$type" in
                    skill) meta_file="SKILL.md" ;;
                    agent) meta_file="AGENT.md" ;;
                esac

                # 1. Check if root contains metadata file
                if [[ -n "$meta_file" ]] && [[ -f "$source_dir/$meta_file" ]]; then
                    local name=$(extract_meta_name "$source_dir/$meta_file" "$(basename "$source_dir")")
                    local target_path="$target_dir/$name"
                    mkdir -p "$target_path"
                    cp -R "$source_dir"/* "$target_path/"
                    count=1
                fi

                # 2. Check type subdirectories (skills/, agents/)
                if [[ $count -eq 0 ]] && [[ -z "$path" ]]; then
                    local search_dirs=""
                    case "$type" in
                        skill) search_dirs="skills skill" ;;
                        agent) search_dirs="agents agent" ;;
                        rule)  search_dirs="rules rule" ;;
                    esac

                    for dir in $search_dirs; do
                        if [[ -d "$source_dir/$dir" ]]; then
                            # Look for subdirectories containing SKILL.md/AGENT.md
                            if [[ -n "$meta_file" ]]; then
                                for d in "$source_dir/$dir"/*; do
                                    [[ ! -d "$d" ]] && continue
                                    if [[ -f "$d/$meta_file" ]]; then
                                        local name=$(extract_meta_name "$d/$meta_file" "$(basename "$d")")
                                        mkdir -p "$target_dir/$name"
                                        cp -R "$d"/* "$target_dir/$name/"
                                        ((count++))
                                    fi
                                done
                            fi

                            # If we found items or if it's "rules" (no metadata file needed usually), we are done with this dir
                            if [[ $count -gt 0 ]] || [[ "$type" == "rule" ]]; then
                                source_dir="$source_dir/$dir"
                                break
                            fi
                        fi
                    done
                fi

                # 3. Check src/ directory if still nothing (for skills)
                if [[ $count -eq 0 ]] && [[ "$type" == "skill" ]] && [[ -d "$source_dir/src" ]]; then
                    if [[ -f "$source_dir/src/$meta_file" ]]; then
                        local name=$(extract_meta_name "$source_dir/src/$meta_file" "$(basename "$source_dir")")
                        mkdir -p "$target_dir/$name"
                        cp -R "$source_dir/src"/* "$target_dir/$name/"
                        count=1
                    fi
                fi

                # Fallback check (rules only): copy individual .md files
                if [[ $count -eq 0 ]] && [[ "$type" == "rule" ]]; then
                    for file in "$source_dir"/*.md; do
                        [[ ! -f "$file" ]] && continue
                        local filename=$(basename "$file")
                        if [[ "$filename" == "README.md" ]]; then
                            local other_mds=$(ls "$source_dir"/*.md 2>/dev/null | grep -v "README.md" | wc -l)
                            [[ $other_mds -gt 0 ]] && continue
                        fi
                        cp "$file" "$target_dir/$filename"
                        ((count++))
                    done
                fi

                if [[ $count -gt 0 ]]; then
                    log_ok "Added $count ${type}(s) from $owner/$repo"
                else
                    # Show actual searched path
                    local searched_path="${source_dir#$tmp_dir/$repo}"
                    searched_path="${searched_path#/}"
                    log_warn "No $type found organized in $owner/$repo${searched_path:+/$searched_path}"
                fi
            else
                log_error "Path not found: $path"
                rm -rf "$tmp_dir"
                return 1
            fi

            rm -rf "$tmp_dir"
        else
            rm -rf "$tmp_dir"
            log_error "Failed to clone: $clone_url"
            return 1
        fi
    fi
}

# Add skill to skills directory
add_skill() {
    local input="$1"

    if [[ -z "$input" ]]; then
        log_error "Usage: ai-global skill <file|github-repo>"
        echo ""
        echo "Examples:"
        echo "  ai-global skill user/repo"
        echo "  ai-global skill https://github.com/user/repo"
        return 1
    fi

    local target_dir="$SKILLS_DIR"
    mkdir -p "$target_dir"

    # Check if it's a GitHub reference
    if is_github_ref "$input"; then
        download_from_github "skill" "$input" "$target_dir"
    else
        log_error "Invalid input. Please provide a GitHub repository."
        echo ""
        echo "Examples:"
        echo "  ai-global skill user/repo"
        echo "  ai-global skill https://github.com/user/repo"
        return 1
    fi
}

# Uninstall
uninstall() {
    log_warn "This will:"
    echo "  1. Unlink all tools to original configuration"
    echo "  2. Remove ~/.ai-global directory"
    echo "  3. Remove ai-global from PATH"
    echo ""
    read -p "Are you sure? (y/N) " -r
    echo ""

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Cancelled"
        return
    fi

    unlink_all_tools

    [[ -L /usr/local/bin/ai-global ]] && rm -f /usr/local/bin/ai-global
    [[ -L "$HOME/.local/bin/ai-global" ]] && rm -f "$HOME/.local/bin/ai-global"

    rm -rf "$CONFIG_DIR"

    log_ok "AI Global uninstalled"
}

# Show version
show_version() {
    echo "ai-global version $VERSION"
}

# Upgrade
upgrade() {
    log_info "Checking for updates..."

    local remote_version
    remote_version=$(curl -fsSL "https://raw.githubusercontent.com/nanxiaobei/ai-global/main/ai-global" 2>/dev/null | grep '^VERSION=' | head -1 | sed 's/VERSION="\([^"]*\)"/\1/')

    if [[ -z "$remote_version" ]]; then
        log_warn "Could not check for updates"
        return 1
    fi

    if [[ "$remote_version" == "$VERSION" ]]; then
        log_ok "Already at latest version ($VERSION)"
        return 0
    fi

    log_info "Upgrading: $VERSION -> $remote_version"

    local current_script="$0"
    # If running via symlink, update the target
    if [[ -L "$current_script" ]]; then
        current_script=$(readlink "$current_script")
    fi

    local exec_temp=$(mktemp)
    if curl -fsSL "https://raw.githubusercontent.com/nanxiaobei/ai-global/main/ai-global" -o "$exec_temp" 2>/dev/null; then
        chmod +x "$exec_temp"
        mv "$exec_temp" "$current_script"

        log_ok "Upgraded to v$remote_version"
        
        # Check and rename global.md to AGENTS.md after upgrade
        if [[ -f "$CONFIG_DIR/global.md" ]]; then
            log_info "Found legacy global.md file, renaming to AGENTS.md..."
            mv "$CONFIG_DIR/global.md" "$CONFIG_DIR/AGENTS.md"
            log_ok "Renamed global.md to AGENTS.md"
        fi
    else
        rm -f "$exec_temp"
        log_error "Failed to download update"
        return 1
    fi
}

# Show help
show_help() {
    echo -e "${BLUE}AI Global: Unified AI Tools Configuration Manager${NC} v$VERSION"
    echo ""
    echo -e "${BLUE}USAGE:${NC}"
    echo -e "  ai-global [command]"
    echo ""
    echo -e "${BLUE}CORE COMMANDS:${NC}"
    echo -e "  ${GREEN}(default)${NC}           Scan, merge, update symlinks"
    echo -e "  ${GREEN}status${NC}              Show symlink status"
    echo -e "  ${GREEN}list${NC}                List all supported AI tools"
    echo -e "  ${GREEN}backups${NC}             List available backups"
    echo -e "  ${GREEN}unlink <key>${NC}        Restore a tool's original config"
    echo -e "  ${GREEN}unlink all${NC}          Restore all tools"
    echo ""
    echo -e "${BLUE}RESOURCE MANAGEMENT:${NC}"
    echo -e "  ${GREEN}skill <user/repo>${NC}   Add a skill"
    echo ""
    echo -e "${BLUE}SYSTEM COMMANDS:${NC}"
    echo -e "  ${GREEN}upgrade${NC}             Upgrade ai-global to latest version"
    echo -e "  ${GREEN}uninstall${NC}           Completely remove ai-global"
    echo -e "  ${GREEN}version${NC}             Show version"
    echo -e "  ${GREEN}help${NC}                Show this help"
    echo ""
}

# Main
main() {
    local cmd="${1:-update}"

    if [[ "$1" == "-v" ]] || [[ "$1" == "--version" ]] || [[ "$1" == "version" ]]; then
        show_version
        exit 0
    fi

    case "$cmd" in
        help|--help|-h) show_help; exit 0 ;;
        list) list_supported; exit 0 ;;
        version|-v|--version) show_version; exit 0 ;;
        skill|unlink|status|backups|upgrade|uninstall)
            if [[ ! -d "$CONFIG_DIR" ]]; then
                log_info "No configuration found. Running initial scan..."
                update_tools
                [[ "$cmd" == "skill" || "$cmd" == "status" ]] || exit 0
            fi
            ;;
        version|-v|--version|help|--help|-h) ;;
        *) cmd="update" ;;
    esac

    case "$cmd" in
        update)       update_tools ;;
        status)       show_status ;;
        list)         list_supported ;;
        backups)      list_backups ;;
        unlink)       unlink_tool "$2" ;;
        skill)        add_skill "$2" ;;
        upgrade)      upgrade ;;
        uninstall)    uninstall ;;
        version|-v|--version) show_version ;;
        help|--help|-h) show_help ;;
        *)            log_error "Unknown command: $cmd"; show_help; exit 1 ;;
    esac
}

main "$@"
