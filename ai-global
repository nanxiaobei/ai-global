#!/bin/bash

# AI-Global: Unified AI Tools Configuration Manager
# https://github.com/nanxiaobei/ai-global

set -e

CONFIG_DIR="$HOME/.ai-global"
BACKUP_DIR="$CONFIG_DIR/backups"
GLOBAL_MD="$CONFIG_DIR/global.md"
SKILLS_DIR="$CONFIG_DIR/skills"
AGENTS_DIR="$CONFIG_DIR/agents"
RULES_DIR="$CONFIG_DIR/rules"
COMMANDS_DIR="$CONFIG_DIR/commands"
PROMPTS_DIR="$CONFIG_DIR/prompts"

# Version (read from package.json)
# Prefer node for correct JSON parsing; fallback to grep/sed; finally fallback to a default.
VERSION=""
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PACKAGE_JSON="$SCRIPT_DIR/package.json"

if [[ -f "$PACKAGE_JSON" ]]; then
    if command -v node >/dev/null 2>&1; then
        VERSION=$(node -p "try{require(process.env.PACKAGE_JSON).version||''}catch(e){''}" 2>/dev/null PACKAGE_JSON="$PACKAGE_JSON")
    fi

    if [[ -z "$VERSION" ]]; then
        VERSION=$(grep '"version"' "$PACKAGE_JSON" 2>/dev/null | head -1 | sed 's/.*"version": *"\([^"]*\)".*/\1/')
    fi
fi

VERSION=${VERSION:-""}

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BRIGHT_RED='\033[1;31m'
BRIGHT_GREEN='\033[1;32m'
BRIGHT_YELLOW='\033[1;33m'
BRIGHT_BLUE='\033[1;34m'
BRIGHT_MAGENTA='\033[1;35m'
BRIGHT_CYAN='\033[1;36m'
NC='\033[0m'

# Tool color palette (using xterm-256 colors for more variety)
# We pick a spread of colors from the 256-color palette (avoiding too dark/grayscale)
TOOL_COLORS=(
    "\033[38;5;39m"  "\033[38;5;214m" "\033[38;5;118m" "\033[38;5;171m" "\033[38;5;208m"
    "\033[38;5;45m"  "\033[38;5;190m" "\033[38;5;161m" "\033[38;5;111m" "\033[38;5;220m"
    "\033[38;5;75m"  "\033[38;5;202m" "\033[38;5;112m" "\033[38;5;141m" "\033[38;5;210m"
    "\033[38;5;47m"  "\033[38;5;226m" "\033[38;5;201m" "\033[38;5;81m"  "\033[38;5;215m"
    "\033[38;5;51m"  "\033[38;5;184m" "\033[38;5;197m" "\033[38;5;105m" "\033[38;5;209m"
    "\033[38;5;121m" "\033[38;5;227m" "\033[38;5;165m" "\033[38;5;33m"  "\033[38;5;216m"
    "\033[38;5;159m" "\033[38;5;178m" "\033[38;5;162m" "\033[38;5;117m" "\033[38;5;221m"
    "\033[38;5;78m"  "\033[38;5;203m" "\033[38;5;113m" "\033[38;5;142m" "\033[38;5;211m"
    "\033[38;5;159m" "\033[38;5;178m" "\033[38;5;162m" "\033[38;5;117m" "\033[38;5;221m"
    "\033[38;5;78m"  "\033[38;5;203m" "\033[38;5;113m" "\033[38;5;142m" "\033[38;5;211m"
)

beautify_path() {
    local path="$1"
    if [[ "$path" == "$HOME"* ]]; then
        local beautified="~${path#$HOME}"
        echo "${beautified//\/\///}"
    else
        echo "$path"
    fi
}

get_tool_color() {
    local name="$1"
    local sum=0
    # Simple hash to pick a stable color index
    for (( i=0; i<${#name}; i++ )); do
        sum=$((sum + $(printf '%d' "'${name:$i:1}")))
    done
    echo -e "${TOOL_COLORS[$((sum % ${#TOOL_COLORS[@]}))]}"
}

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_ok() { echo -e "${GREEN}[OK]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Known AI tool patterns
# Format: dir|name|instr_file|skills_dir|agents_dir|rules_dir|commands_dir|prompts_dir
declare -a KNOWN_PATTERNS=(
    ".claude|Claude Code|CLAUDE.md|skills|.|.|commands|."
    ".cursor|Cursor|rules/global.md|skills|.|.|.|prompts"
    ".factory|Factory Droid|droids/global.md|.|.|.|.|."
    ".amp|Amp|instructions.md|.|.|.|.|."
    ".antigravity|Antigravity|CLAUDE.md|skills|.|.|commands|."
    ".gemini|Gemini CLI|GEMINI.md|skills|.|.|commands|."
    ".kiro|Kiro|steering/global.md|.|agents|.|.|."
    ".opencode|OpenCode|instructions.md|.|.|.|.|."
    ".qoder|Qoder|instructions.md|.|.|.|.|."
    ".qodo|Qodo|instructions.md|.|agents|.|.|."
    ".config/github-copilot|GitHub Copilot|instructions.md|.|.|.|.|."
    ".aider|Aider|.aider.conf.yml|.|.|.|.|."
    ".continue|Continue|config.json|.|.|rules|.|prompts"
    ".codeium|Codeium|config.json|.|.|.|.|."
    ".tabnine|TabNine|tabnine_config.json|.|.|.|.|."
    ".sourcegraph|Sourcegraph Cody|cody.json|.|.|.|commands|."
    ".codegpt|CodeGPT|settings.json|.|.|.|.|prompts"
    ".windsurf|Windsurf|instructions.md|skills|agents|rules|.|."
    ".trae|Trae|instructions.md|.|.|.|.|."
    ".melty|Melty|instructions.md|.|.|.|.|."
    ".void|Void|instructions.md|.|.|.|.|."
    ".roo|Roo Code|instructions.md|.|.|rules|.|."
    ".zed|Zed|settings.json|.|.|.|.|."
    ".cline|Cline|instructions.md|.|.|rules|.|prompts"
    ".aide|Aide|instructions.md|.|.|.|.|."
    ".pear|PearAI|instructions.md|.|.|.|.|."
    ".supermaven|Supermaven|config.json|.|.|.|.|."
    ".codestory|CodeStory|instructions.md|.|.|.|.|."
    ".double|Double|instructions.md|.|.|.|.|."
    ".blackbox|Blackbox AI|config.json|.|.|.|.|."
    ".amazonq|Amazon Q|instructions.md|.|.|.|.|."
    ".copilot-workspace|Copilot Workspace|instructions.md|.|.|.|.|."
    ".codex|OpenAI Codex|instructions.md|skills|agents|rules|.|."
    ".goose|Goose AI|instructions.md|skills|agents|rules|.|."
    ".mentat|Mentat|instructions.md|skills|agents|rules|.|."
    ".gpt-engineer|GPT Engineer|instructions.md|skills|agents|rules|.|prompts"
    ".smol|Smol Developer|instructions.md|skills|agents|rules|.|prompts"
    ".config/opencode|OpenCode Config|instructions.md|.|.|.|.|."
)

# Backup a file or directory
backup_item() {
    local source="$1"
    local tool_dir="$2"
    local type="$3"

    [[ ! -e "$source" ]] && return 0
    [[ -L "$source" ]] && return 0

    mkdir -p "$BACKUP_DIR"

    local backup_name=$(echo "$tool_dir" | tr '/' '_')
    local timestamp=$(date +%s)
    local backup_path="$BACKUP_DIR/${backup_name}.${type}.${timestamp}"

    if [[ -d "$source" ]]; then
        cp -r "$source" "$backup_path" 2>/dev/null || return 0
    else
        cp "$source" "$backup_path" 2>/dev/null || return 0
    fi

    log_ok "Backed up: $source"
}

# Merge items from a tool to shared directory (dedup by filename)
merge_items() {
    local source_dir="$1"
    local target_dir="$2"
    local type="$3"
    local tool_name="$4"

    [[ ! -d "$source_dir" ]] && return
    [[ -L "$source_dir" ]] && return

    local merged_count=0

    for item in "$source_dir"/*; do
        [[ ! -e "$item" ]] && continue
        local name=$(basename "$item")
        local target="$target_dir/$name"

        [[ -e "$target" ]] && continue

        if [[ -d "$item" ]]; then
            cp -r "$item" "$target"
        else
            cp "$item" "$target"
        fi
        ((merged_count++))
    done

    if [[ $merged_count -gt 0 ]]; then
        local tool_color=$(get_tool_color "$tool_name")
        log_ok "Merged $merged_count $type from ${tool_color}${tool_name}${NC}"
    fi
}

# Count items in directory (dirs and files)
count_items() {
    local dir="$1"
    if [[ -d "$dir" ]]; then
        ls -1 "$dir" 2>/dev/null | wc -l | tr -d ' '
    else
        echo "0"
    fi
}

# Create symlink
create_symlink() {
    local source="$1"
    local target="$2"

    [[ ! -e "$source" ]] && return

    local target_dir=$(dirname "$target")
    mkdir -p "$target_dir"

    # If target exists and is a real file/dir, it should have been backed up by backup_item already.
    # We remove it to make room for the symlink, avoiding in-place backups.
    if [[ -e "$target" ]] && [[ ! -L "$target" ]]; then
        rm -rf "$target"
    fi

    [[ -L "$target" ]] && rm "$target"
    ln -s "$source" "$target"
}

# Show symlink status
show_status() {
    log_info "Symlink status:"
    echo ""

    local total_links=0

    # Instructions
    local instr_output=""
    for pattern in "${KNOWN_PATTERNS[@]}"; do
        local p_dir p_name p_instr p_skills p_agents p_rules p_cmds p_prompts
        IFS='|' read -r p_dir p_name p_instr p_skills p_agents p_rules p_cmds p_prompts <<< "$pattern"

        if [[ "$p_instr" != "." ]] && [[ "$p_instr" != *.json ]] && [[ "$p_instr" != *.yml ]]; then
            local target="$HOME/$p_dir/$p_instr"
            if [[ -L "$target" ]]; then
                local link_target=$(readlink "$target" 2>/dev/null || true)
                if [[ "$link_target" == *".ai-global"* ]]; then
                    local tool_color=$(get_tool_color "$p_name")
                    instr_output+="  ${tool_color}✓ $(beautify_path "$target")${NC}\n"
                    ((total_links++))
                fi
            fi
        fi
    done

    if [[ -n "$instr_output" ]]; then
        echo -e "${BLUE}[global.md]${NC}"
        echo -e -n "$instr_output"
    fi

    for type_name in skills agents rules commands prompts; do
        local type_output=""
        for pattern in "${KNOWN_PATTERNS[@]}"; do
            local p_dir p_name p_instr p_skills p_agents p_rules p_cmds p_prompts
            IFS='|' read -r p_dir p_name p_instr p_skills p_agents p_rules p_cmds p_prompts <<< "$pattern"

            local type_dir=""
            case "$type_name" in
                skills)   type_dir="$p_skills" ;;
                agents)   type_dir="$p_agents" ;;
                rules)    type_dir="$p_rules" ;;
                commands) type_dir="$p_cmds" ;;
                prompts)  type_dir="$p_prompts" ;;
            esac

            if [[ "$type_dir" != "." ]]; then
                local target="$HOME/$p_dir/$type_dir"
                if [[ -L "$target" ]]; then
                    local link_target=$(readlink "$target" 2>/dev/null || true)
                    if [[ "$link_target" == *".ai-global"* ]]; then
                        local tool_color=$(get_tool_color "$p_name")
                        type_output+="  ${tool_color}✓ $(beautify_path "$target")${NC}\n"
                        ((total_links++))
                    fi
                fi
            fi
        done

        if [[ -n "$type_output" ]]; then
            echo -e "\n${BLUE}[$type_name]${NC}"
            echo -e -n "$type_output"
        fi
    done

    if [[ $total_links -eq 0 ]]; then
        echo "  No active symlinks found."
    fi

    echo ""
    log_info "Shared items: skills=$(count_items "$SKILLS_DIR"), agents=$(count_items "$AGENTS_DIR"), rules=$(count_items "$RULES_DIR"), commands=$(count_items "$COMMANDS_DIR"), prompts=$(count_items "$PROMPTS_DIR")"
}

# List supported tools
list_supported() {
    log_info "Supported AI tools:"
    echo ""
    printf "  ${BLUE}%-22s %-20s %-10s %-10s %-10s %-10s %-10s %s${NC}\n" "Directory" "Tool" "Skills" "Agents" "Rules" "Cmds" "Prompts" "Status"
    echo "  --------------------------------------------------------------------------------------------------------------------------------"

    for pattern in "${KNOWN_PATTERNS[@]}"; do
        local p_dir p_name p_instr p_skills p_agents p_rules p_cmds p_prompts
        IFS='|' read -r p_dir p_name p_instr p_skills p_agents p_rules p_cmds p_prompts <<< "$pattern"
        local full_path="$HOME/$p_dir"

        local s_str="." a_str="." r_str="." c_str="." p_str="."
        if [[ -d "$full_path" ]]; then
            [[ "$p_skills" != "." && -d "$full_path/$p_skills" ]] && s_str="✓"
            [[ "$p_agents" != "." && -d "$full_path/$p_agents" ]] && a_str="✓"
            [[ "$p_rules" != "." && -d "$full_path/$p_rules" ]] && r_str="✓"
            [[ "$p_cmds" != "." && -d "$full_path/$p_cmds" ]] && c_str="✓"
            # Prompts can be a file or dir
            [[ "$p_prompts" != "." && -e "$full_path/$p_prompts" ]] && p_str="✓"
        fi

        local status=""
        local tool_color=""
        if [[ -d "$full_path" ]]; then
            status="${GREEN}Installed${NC}"
            tool_color=$(get_tool_color "$p_name")
        else
            status="${YELLOW}Not found${NC}"
            tool_color="${NC}"
        fi

        # Use manual padding because printf handles multibyte characters (✓) by byte count in Bash 3.2.
        # Each category block matches the header's "%-10s " (11 characters total).
        # We use indicator + 10 spaces = 11 characters.
        printf "  %b%-22s %-20s%b %s          %s          %s          %s          %s          %b\n" \
            "$tool_color" "$p_dir" "$p_name" "$NC" "$s_str" "$a_str" "$r_str" "$c_str" "$p_str" "$status"
    done
    echo ""
}

# List available backups
list_backups() {
    log_info "Available backups:"
    echo ""

    # Use ls -A to catch hidden files/dirs (starting with .)
    local backups_list=$(ls -A "$BACKUP_DIR" 2>/dev/null || true)

    if [[ -z "$backups_list" ]]; then
        echo "  No backups found"
        echo ""
        return
    fi

    printf "  ${BLUE}%-25s %-12s %s${NC}\n" "Tool" "Type" "Backup File"
    echo "  --------------------------------------------------------------------"

    while read -r filename; do
        [[ -z "$filename" ]] && continue
        local tool_name=""
        local type=""

        # Improved regex to handle various path characters
        if [[ "$filename" =~ ^(.+)\.([^\.]+)\.([0-9]+)$ ]]; then
            tool_name="${BASH_REMATCH[1]}"
            type="${BASH_REMATCH[2]}"
        else
            tool_name="$filename"
            type="unknown"
        fi

        local tool_color=$(get_tool_color "${tool_name//_/ }")
        printf "  %s%-25s %-12s %s%b\n" "$tool_color" "$tool_name" "$type" "$filename" "$NC"
    done <<< "$backups_list"
    echo ""
}

# Collect and merge instructions from all tools
collect_instructions() {
    local merged_content=""
    local found_count=0

    for pattern in "${KNOWN_PATTERNS[@]}"; do
        IFS='|' read -r dir_name tool_name instr_file skills agents rules commands prompts <<< "$pattern"

        if [[ "$instr_file" != "." ]] && [[ "$instr_file" != *.json ]] && [[ "$instr_file" != *.yml ]]; then
            local actual_path="$HOME/$dir_name/$instr_file"
            [[ -L "$actual_path" ]] && continue

            if [[ -f "$actual_path" ]]; then
                local content=$(cat "$actual_path" 2>/dev/null)
                if [[ -n "$content" ]]; then
                    if [[ $found_count -gt 0 ]]; then
                        merged_content+="\n\n---\n\n"
                    fi
                    merged_content+="# From $tool_name\n\n$content"
                    ((found_count++))
                fi
            fi
        fi
    done

    if [[ $found_count -gt 0 ]]; then
        echo -e "$merged_content" > "$GLOBAL_MD"
        log_ok "Merged instructions from $found_count tool(s)"
    else
        cat > "$GLOBAL_MD" << 'EOF'
# AI Assistant Instructions

<!-- Add your instructions here. They will sync to all AI tools. -->
EOF
        log_ok "Created: $GLOBAL_MD"
    fi
}

# Update: scan, merge and link tools
update_tools() {
    log_info "Scanning for AI tools..."
    echo ""

    mkdir -p "$SKILLS_DIR" "$AGENTS_DIR" "$RULES_DIR" "$COMMANDS_DIR" "$PROMPTS_DIR" "$BACKUP_DIR"

    collect_instructions

    local tool_count=0

    for pattern in "${KNOWN_PATTERNS[@]}"; do
        IFS='|' read -r dir_name tool_name instr_file skills agents rules commands prompts <<< "$pattern"
        local full_path="$HOME/$dir_name"

        if [[ -d "$full_path" ]]; then
            local color=$(get_tool_color "$tool_name")
            echo -e "${GREEN}[OK]${NC} ${color}Found: $tool_name${NC}"
            ((tool_count++))

            if [[ "$instr_file" != "." ]] && [[ "$instr_file" != *.json ]] && [[ "$instr_file" != *.yml ]]; then
                local actual_path="$HOME/$dir_name/$instr_file"
                backup_item "$actual_path" "$dir_name" "instructions"
            fi

            for type_name in skills agents rules commands prompts; do
                local type_dir=""
                case "$type_name" in
                    skills) type_dir="$skills" ;;
                    agents) type_dir="$agents" ;;
                    rules) type_dir="$rules" ;;
                    commands) type_dir="$commands" ;;
                    prompts) type_dir="$prompts" ;;
                esac
                if [[ "$type_dir" != "." ]]; then
                    local path="$HOME/$dir_name/$type_dir"
                    backup_item "$path" "$dir_name" "$type_name"
                    local target_dir=""
                    case "$type_name" in
                        skills) target_dir="$SKILLS_DIR" ;;
                        agents) target_dir="$AGENTS_DIR" ;;
                        rules) target_dir="$RULES_DIR" ;;
                        commands) target_dir="$COMMANDS_DIR" ;;
                        prompts) target_dir="$PROMPTS_DIR" ;;
                    esac
                    merge_items "$path" "$target_dir" "$type_name" "$tool_name"
                fi
            done
        fi
    done

    if [[ $tool_count -eq 0 ]]; then
        log_info "No AI tools found."
        return
    fi

    echo ""
    log_info "Creating symlinks..."

    for pattern in "${KNOWN_PATTERNS[@]}"; do
        IFS='|' read -r dir_name tool_name instr_file skills agents rules commands prompts <<< "$pattern"
        local full_path="$HOME/$dir_name"

        if [[ -d "$full_path" ]]; then
            local tool_color=$(get_tool_color "$tool_name")
            if [[ "$instr_file" != "." ]] && [[ "$instr_file" != *.json ]] && [[ "$instr_file" != *.yml ]]; then
                local target="$HOME/$dir_name/$instr_file"
                create_symlink "$GLOBAL_MD" "$target"
                printf "  ${tool_color}✓ %-40s -> %s${NC}\n" "$(beautify_path "$target")" "$(beautify_path "$GLOBAL_MD")"
            fi

            for type_name in skills agents rules commands prompts; do
                local type_dir=""
                local source_dir=""
                case "$type_name" in
                    skills) type_dir="$skills"; source_dir="$SKILLS_DIR" ;;
                    agents) type_dir="$agents"; source_dir="$AGENTS_DIR" ;;
                    rules) type_dir="$rules"; source_dir="$RULES_DIR" ;;
                    commands) type_dir="$commands"; source_dir="$COMMANDS_DIR" ;;
                    prompts) type_dir="$prompts"; source_dir="$PROMPTS_DIR" ;;
                esac
                if [[ "$type_dir" != "." ]]; then
                    local target="$HOME/$dir_name/$type_dir"
                    create_symlink "$source_dir" "$target"
                    printf "  ${tool_color}✓ %-40s -> %s${NC}\n" "$(beautify_path "$target")" "$(beautify_path "$source_dir")/"
                fi
            done
        fi
    done

    echo ""
    log_info "Done! Shared: skills=$(count_items "$SKILLS_DIR"), agents=$(count_items "$AGENTS_DIR"), rules=$(count_items "$RULES_DIR"), commands=$(count_items "$COMMANDS_DIR"), prompts=$(count_items "$PROMPTS_DIR")"
}

# Unlink a single tool
unlink_single_tool() {
    local tool_name="$1"
    local dir_name="$2"
    local instr_file="$3"
    local skills="$4"
    local agents="$5"
    local rules="$6"
    local commands="$7"
    local prompts="$8"
    local silent="${9:-false}"

    local backup_name=$(echo "$dir_name" | tr '/' '_')
    local worked=false

    # Check for instructions link
    if [[ "$instr_file" != "." ]]; then
        local target="$HOME/$dir_name/$instr_file"
        if [[ -L "$target" ]]; then
            local link_target=$(readlink "$target" 2>/dev/null || true)
            if [[ "$link_target" == *".ai-global"* ]]; then
                rm "$target"
                local backup_file=$(ls -t "$BACKUP_DIR"/${backup_name}.instructions.* 2>/dev/null | head -1)
                [[ -f "$backup_file" ]] && cp "$backup_file" "$target"
                worked=true
            fi
        fi
    fi

    # Check for components links
    for type_name in skills agents rules commands prompts; do
        local type_dir=""
        case "$type_name" in
            skills) type_dir="$skills" ;;
            agents) type_dir="$agents" ;;
            rules) type_dir="$rules" ;;
            commands) type_dir="$commands" ;;
            prompts) type_dir="$prompts" ;;
        esac
        if [[ "$type_dir" != "." ]]; then
            local target="$HOME/$dir_name/$type_dir"
            if [[ -L "$target" ]]; then
                local link_target=$(readlink "$target" 2>/dev/null || true)
                if [[ "$link_target" == *".ai-global"* ]]; then
                    rm "$target"
                    local backup_file=$(ls -td "$BACKUP_DIR"/${backup_name}.${type_name}.* 2>/dev/null | head -1)
                    if [[ -d "$backup_file" ]]; then
                        cp -r "$backup_file" "$target"
                    fi
                    worked=true
                fi
            fi
        fi
    done

    # Check for backups persistence
    local has_backups=false
    if [[ -n "$(ls "$BACKUP_DIR"/${backup_name}.* 2>/dev/null)" ]]; then
        has_backups=true
        rm -rf "$BACKUP_DIR"/${backup_name}.* 2>/dev/null || true
    fi

    if [[ "$worked" == true ]] || [[ "$has_backups" == true ]]; then
        if [[ "$silent" != "true" ]]; then
            local color=$(get_tool_color "$tool_name")
            echo -e "${GREEN}[OK]${NC} ${color}Unlinked: $tool_name${NC}"
        fi
        return 0
    fi

    return 1
}

# Unlink all tools
unlink_all_tools() {
    log_info "Unlinking tools..."
    echo ""

    local unlinked_count=0
    # Scan all known patterns to find and remove any symlinks
    for pattern in "${KNOWN_PATTERNS[@]}"; do
        IFS='|' read -r dir_name tool_name instr_file skills agents rules commands prompts <<< "$pattern"
        if unlink_single_tool "$tool_name" "$dir_name" "$instr_file" "$skills" "$agents" "$rules" "$commands" "$prompts"; then
            ((unlinked_count++))
        fi
    done

    # Final sweep for any remaining symlinks pointing to .ai-global
    find "$HOME" -maxdepth 3 -type l 2>/dev/null | while read -r link; do
        local target=$(readlink "$link" 2>/dev/null || true)
        if [[ "$target" == *".ai-global"* ]]; then
            rm "$link"
            log_ok "Removed unknown symlink: $(beautify_path "$link")"
            ((unlinked_count++))
        fi
    done

    # Clear all backups as requested
    rm -rf "$BACKUP_DIR"/* 2>/dev/null || true

    echo ""
    if [[ $unlinked_count -gt 0 ]]; then
        log_info "Unlinked $unlinked_count item(s) and cleared backups. Shared data preserved."
    else
        log_info "No active symlinks found. Backups cleared."
    fi
}

# Unlink a specific tool
unlink_tool() {
    local tool_query="$1"

    if [[ -z "$tool_query" ]]; then
        log_error "Usage: ai-global unlink <tool> or ai-global unlink all"
        echo ""
        list_backups
        return 1
    fi

    if [[ "$tool_query" == "all" ]]; then
        unlink_all_tools
        return
    fi

    local found=false

    for pattern in "${KNOWN_PATTERNS[@]}"; do
        IFS='|' read -r dir_name tool_name instr_file skills agents rules commands prompts <<< "$pattern"
        local tool_lower=$(echo "$tool_name" | tr '[:upper:]' '[:lower:]')
        local query_lower=$(echo "$tool_query" | tr '[:upper:]' '[:lower:]')

        if [[ "$tool_lower" == *"$query_lower"* ]] || [[ "$dir_name" == *"$query_lower"* ]]; then
            if ! unlink_single_tool "$tool_name" "$dir_name" "$instr_file" "$skills" "$agents" "$rules" "$commands" "$prompts"; then
                log_info "$tool_name is not currently linked."
            fi
            found=true
            break
        fi
    done

    if [[ "$found" == false ]]; then
        log_error "Tool not found: $tool_query"
        echo ""
        echo "Use 'ai-global list' to see supported tools"
        return 1
    fi
}

# Check if input is a GitHub reference
is_github_ref() {
    local input="$1"
    # Match: user/repo, https://github.com/user/repo, github.com/user/repo
    if [[ "$input" =~ ^https?://github\.com/ ]] || \
       [[ "$input" =~ ^github\.com/ ]] || \
       [[ "$input" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+(/.*)?$ ]]; then
        return 0
    fi
    return 1
}

# Parse GitHub reference to get owner, repo, and optional path
parse_github_ref() {
    local input="$1"

    # Remove https://github.com/ or github.com/ prefix
    input="${input#https://github.com/}"
    input="${input#http://github.com/}"
    input="${input#github.com/}"

    # Remove /blob/main/ or /blob/master/ or /tree/main/ etc for file/dir paths
    input=$(echo "$input" | sed -E 's|/blob/[^/]+/|/|; s|/tree/[^/]+/|/|')

    echo "$input"
}

# Download from GitHub
download_from_github() {
    local type="$1"
    local ref="$2"
    local target_dir="$3"

    local parsed=$(parse_github_ref "$ref")
    local owner=$(echo "$parsed" | cut -d'/' -f1)
    local repo=$(echo "$parsed" | cut -d'/' -f2)
    local path=$(echo "$parsed" | cut -d'/' -f3-)

    if [[ -z "$owner" ]] || [[ -z "$repo" ]]; then
        log_error "Invalid GitHub reference: $ref"
        return 1
    fi

    # If path points to a specific file
    if [[ -n "$path" ]] && [[ "$path" == *.md ]]; then
        local filename=$(basename "$path")
        local raw_url="https://raw.githubusercontent.com/$owner/$repo/main/$path"

        log_info "Downloading: $raw_url"

        if curl -fsSL "$raw_url" -o "$target_dir/$filename" 2>/dev/null; then
            log_ok "Added $type: $target_dir/$filename"
        else
            # Try master branch
            raw_url="https://raw.githubusercontent.com/$owner/$repo/master/$path"
            if curl -fsSL "$raw_url" -o "$target_dir/$filename" 2>/dev/null; then
                log_ok "Added $type: $target_dir/$filename"
            else
                log_error "Failed to download: $ref"
                return 1
            fi
        fi
    else
        # Clone entire repo or subdirectory
        local tmp_dir=$(mktemp -d)
        local clone_url="https://github.com/$owner/$repo.git"

        log_info "Cloning: $clone_url"

        if git clone --depth 1 --single-branch "$clone_url" "$tmp_dir/$repo"; then
            local source_dir="$tmp_dir/$repo"
            [[ -n "$path" ]] && source_dir="$tmp_dir/$repo/$path"

            if [[ -d "$source_dir" ]]; then
                # Auto-detect type subdirectory (e.g., skills/, agents/, rules/)
                if [[ -z "$path" ]]; then
                    local type_dirs=""
                    case "$type" in
                        skill)   type_dirs="skills skill" ;;
                        agent)   type_dirs="agents agent" ;;
                        rule)    type_dirs="rules rule" ;;
                        command) type_dirs="commands command" ;;
                        prompt)  type_dirs="prompts prompt" ;;
                    esac

                    # Prefer type subdirectory, fallback to root
                    for dir in $type_dirs; do
                        if [[ -d "$source_dir/$dir" ]]; then
                            source_dir="$source_dir/$dir"
                            log_info "Found $dir/ directory"
                            break
                        fi
                    done
                fi

                local count=0

                # Special case: many skill repos are structured as:
                # skills/<skill-name>/SKILL.md
                if [[ "$type" == "skill" ]] && [[ "$(basename "$source_dir")" == "skills" ]]; then
                    for d in "$source_dir"/*; do
                        [[ ! -d "$d" ]] && continue
                        local skill_md="$d/SKILL.md"
                        [[ ! -f "$skill_md" ]] && continue

                        local skill_name=$(basename "$d")

                        # Copy the entire skill directory so assets/examples are preserved
                        local target_skill_dir="$target_dir/$skill_name"
                        mkdir -p "$target_skill_dir"
                        cp -R "$d/" "$target_skill_dir/"

                        ((count++))
                    done
                fi

                # Fallback: copy top-level .md files from the selected source directory
                if [[ $count -eq 0 ]]; then
                    for file in "$source_dir"/*.md; do
                        [[ ! -f "$file" ]] && continue
                        local filename=$(basename "$file")
                        cp "$file" "$target_dir/$filename"
                        ((count++))
                    done
                fi

                if [[ $count -gt 0 ]]; then
                    log_ok "Added $count ${type}(s) from $owner/$repo"
                else
                    # Show actual searched path
                    local searched_path="${source_dir#$tmp_dir/$repo}"
                    searched_path="${searched_path#/}"
                    log_warn "No skills found in $owner/$repo${searched_path:+/$searched_path}"
                fi
            else
                log_error "Path not found: $path"
                rm -rf "$tmp_dir"
                return 1
            fi

            rm -rf "$tmp_dir"
        else
            rm -rf "$tmp_dir"
            log_error "Failed to clone: $clone_url"
            return 1
        fi
    fi
}

# Add item to a type directory
add_item() {
    local type="$1"
    local input="$2"

    if [[ -z "$input" ]]; then
        log_error "Usage: ai-global $type <file|github-repo>"
        echo ""
        echo "Examples:"
        echo "  ai-global $type react.md"
        echo "  ai-global $type /path/to/file.md"
        echo "  ai-global $type user/repo"
        echo "  ai-global $type https://github.com/user/repo"
        echo "  ai-global $type user/repo/path/to/file.md"
        return 1
    fi

    local target_dir=""
    case "$type" in
        skill)   target_dir="$SKILLS_DIR" ;;
        agent)   target_dir="$AGENTS_DIR" ;;
        rule)    target_dir="$RULES_DIR" ;;
        command) target_dir="$COMMANDS_DIR" ;;
        prompt)  target_dir="$PROMPTS_DIR" ;;
    esac

    mkdir -p "$target_dir"

    # Check if it's a GitHub reference
    if is_github_ref "$input"; then
        download_from_github "$type" "$input" "$target_dir"
    elif [[ -f "$input" ]]; then
        # Local file
        local basename=$(basename "$input")
        cp "$input" "$target_dir/$basename"
        log_ok "Added $type: $target_dir/$basename"
    else
        # Create new file
        local target_file="$target_dir/$input"
        if [[ ! "$input" == *.md ]]; then
            target_file="$target_dir/${input}.md"
        fi
        touch "$target_file"
        log_ok "Created $type: $target_file"
        echo "Edit: $target_file"
    fi
}

# Uninstall
uninstall() {
    log_warn "This will:"
    echo "  1. Unlink all tools to original configuration"
    echo "  2. Remove ~/.ai-global directory"
    echo "  3. Remove ai-global from PATH"
    echo ""
    read -p "Are you sure? (y/N) " -r
    echo ""

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Cancelled"
        return
    fi

    unlink_all_tools

    [[ -L /usr/local/bin/ai-global ]] && rm -f /usr/local/bin/ai-global
    [[ -L "$HOME/.local/bin/ai-global" ]] && rm -f "$HOME/.local/bin/ai-global"

    rm -rf "$CONFIG_DIR"

    log_ok "AI-Global uninstalled"
}

# Show version
show_version() {
    echo "ai-global version $VERSION"
}

# Upgrade
upgrade() {
    log_info "Checking for updates..."

    local remote_version
    remote_version=$(curl -fsSL "https://raw.githubusercontent.com/nanxiaobei/ai-global/main/package.json" 2>/dev/null | grep '"version"' | head -1 | sed 's/.*"version": *"\([^"]*\)".*/\1/')

    if [[ -z "$remote_version" ]]; then
        log_warn "Could not check for updates"
        return 1
    fi

    if [[ "$remote_version" == "$VERSION" ]]; then
        log_ok "Already at latest version ($VERSION)"
        return 0
    fi

    log_info "Upgrading: $VERSION -> $remote_version"

    local current_script="$0"
    # If running via symlink, update the target
    if [[ -L "$current_script" ]]; then
        current_script=$(readlink "$current_script")
    fi

    local tmp_file=$(mktemp)
    if curl -fsSL "https://raw.githubusercontent.com/nanxiaobei/ai-global/main/ai-global" -o "$tmp_file" 2>/dev/null; then
        chmod +x "$tmp_file"
        mv "$tmp_file" "$current_script"
        log_ok "Upgraded to v$remote_version"
    else
        rm -f "$tmp_file"
        log_error "Failed to download update"
        return 1
    fi
}

# Show help
show_help() {
    echo -e "${BLUE}AI-Global: Unified AI Tools Configuration Manager${NC} v$VERSION"
    echo ""
    echo -e "${BLUE}USAGE:${NC}"
    echo -e "  ai-global [command]"
    echo ""
    echo -e "${BLUE}CORE COMMANDS:${NC}"
    echo -e "  ${GREEN}(default)${NC}           Scan, merge and update symlinks"
    echo -e "  ${GREEN}status${NC}              Show symlink status"
    echo -e "  ${GREEN}list${NC}                List all supported AI tools"
    echo -e "  ${GREEN}backups${NC}             List available backups"
    echo -e "  ${GREEN}unlink <tool>${NC}       Unlink a tool's original config"
    echo -e "  ${GREEN}unlink all${NC}          Unlink all tools"
    echo ""
    echo -e "${BLUE}RESOURCE MANAGEMENT:${NC}"
    echo -e "  ${GREEN}skill <source>${NC}      Add a skill (file, GitHub repo, or new)"
    echo -e "  ${GREEN}agent <source>${NC}      Add an agent"
    echo -e "  ${GREEN}rule <source>${NC}       Add a rule"
    echo -e "  ${GREEN}command <source>${NC}    Add a command"
    echo -e "  ${GREEN}prompt <source>${NC}     Add a prompt"
    echo ""
    echo -e "${BLUE}SYSTEM COMMANDS:${NC}"
    echo -e "  ${GREEN}upgrade${NC}             Upgrade ai-global to latest version"
    echo -e "  ${GREEN}uninstall${NC}           Completely remove ai-global"
    echo -e "  ${GREEN}version${NC}             Show version"
    echo -e "  ${GREEN}help${NC}                Show this help"
    echo ""
}

# Main
main() {
    local cmd="${1:-update}"

    if [[ "$1" == "-v" ]] || [[ "$1" == "--version" ]] || [[ "$1" == "version" ]]; then
        show_version
        exit 0
    fi

    case "$cmd" in
        help|--help|-h) show_help; exit 0 ;;
        list) list_supported; exit 0 ;;
        version|-v|--version) show_version; exit 0 ;;
        skill|agent|rule|command|prompt|unlink|status|backups|upgrade|uninstall)
            if [[ ! -d "$CONFIG_DIR" ]]; then
                log_info "No configuration found. Running initial scan..."
                update_tools
                [[ "$cmd" == "skill" || "$cmd" == "agent" || "$cmd" == "rule" || "$cmd" == "command" || "$cmd" == "prompt" || "$cmd" == "status" ]] || exit 0
            fi
            ;;
        version|-v|--version|help|--help|-h) ;;
        *) cmd="update" ;;
    esac

    case "$cmd" in
        update)       update_tools ;;
        status)       show_status ;;
        list)         list_supported ;;
        backups)      list_backups ;;
        unlink)       unlink_tool "$2" ;;
        skill)        add_item "skill" "$2" ;;
        agent)        add_item "agent" "$2" ;;
        rule)         add_item "rule" "$2" ;;
        command)      add_item "command" "$2" ;;
        prompt)       add_item "prompt" "$2" ;;
        upgrade)      upgrade ;;
        uninstall)    uninstall ;;
        version|-v|--version) show_version ;;
        help|--help|-h) show_help ;;
        *)            log_error "Unknown command: $cmd"; show_help; exit 1 ;;
    esac
}

main "$@"
